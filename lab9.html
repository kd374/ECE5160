<!DOCTYPE html>
<html lang="en">
    <head>
		<title>ECE5160 Portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
<body class="is-preload">
		<!-- Wrapper -->
		<!--	<div id="wrapper" class="fade-in"> -->

				<!-- Intro -->
                <div id="intro">
                    <h1>LAB 9</h1>
                    <p>Mapping</p>
                    <ul class="actions">
                        <li><a href="#header" class="button icon solid solo fa-arrow-down scrolly">Continue</a></li>
                    </ul>
                </div>

            <!-- Header -->
            <header id="header">
                    <a href="index.html" class="logo">ECE 5160 | Fast Robots: Lab 9</a>
                </header>

                

            <!-- Nav -->
                <nav id="nav">
                    <ul class="links">
                        <li class="active"><a href="index.html">LAB 9</a></li>
                    </ul>
                    <ul class="icons">
                        <li><a href="https://www.linkedin.com/in/katarina-duric/" class="icon brands fa-linkedin"><span class="label">Linkedin</span></a></li> 
                        <li><a href="https://github.com/kd374" class="icon brands fa-github"><span class="label">GitHub</span></a></li>
                </nav>

				<!-- Main -->
                <div id="main">

                    <!-- Featured Post -->
                    <head>
                        <meta charset="UTF-8">
                        <meta name="viewport" content="width=device-width, initial-scale=1.0">
                        <title>LAB 9</title>
                    
                        <!-- Inline CSS for this page only -->
                        <style>
                            /* Reduce spacing between paragraphs, sections, and images */
                            p, h3, h2, pre, img {
                                margin-bottom: 10px; /* Less space between rows */
                            }
                    
                            /* Reduce spacing between sections */
                            .content-section {
                                margin-bottom: 15px; /* Less space between sections */
                                padding-bottom: 5px;
                                
                                border-bottom: 1px solid #ddd;  /* Adds a light gray line */
                                padding-bottom: 15px;
                                margin-bottom: 20px;

                            }
                    
                            /* Make subtitles (h3) left-aligned */
                            h3 {
                                text-align: left;
                                font-size: 20px; /* Adjust subtitle font size */
                                margin-left: 5px;
                            }
                    
                            /* Center images */
                            .center-content img {
                                display: block;
                                margin: 0 auto;
                                width: 500px; /* Adjust width */
                                height: auto;
                            }

                            .math-equation {
                                font-size: 18px;
                                display:inline-block;
                            }
                    
                            /* Center code blocks */
                            pre {
                                background-color: #f4f4f4;
                                padding: 10px;
                                border-radius: 5px;
                                overflow-x: auto;
                                text-align: left;
                                font-family: monospace;
                            }
                            details {
                                width: 100%;
                                padding: 10px;
                                border: 2px solid #ccc;
                                border-radius: 8px;
                                background-color: #f4f4f4;
                                margin: 10px 0;
                                font-family: 'monospace', Times, serif, sans-serif;
                                transition: all 0.3s ease;
                            }

                            details[open] {
                                background-color: #f4eae7; /* Different bg when expanded */
                                border-color: #ec96ad;
                            }

                            summary {
                                font-weight: bold;
                                cursor: pointer;
                                list-style: none;  /* removes default triangle */
                                position: relative;
                                padding-left: 20px;
                            }

                            /* Optional: Add a custom arrow */
                            summary::before {
                                content: 'â–¶';
                                position: absolute;
                                left: 0;
                                transition: transform 0.3s ease;
                            }

                            details[open] summary::before {
                                transform: rotate(90deg); /* Rotate arrow when open */
                            }

                            summary:focus {
                                outline: none;
                            }
                        </style>
                          <!-- MathJax for LaTeX rendering -->
                        <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
                        <script id="MathJax-script" async
                        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
                        </script>

                        
                    </head>
                    <body>

                    
                        <!-- Featured Post -->
                        <article class="post featured">
                            <header class="major">
                                <span class="date">April 16th, 2025</span>
                                <h2>LAB 9 - Mapping</h2>
                            </header>
                    
                            <!-- Introduction -->
                            <section class="content-section">
                            <h3>Introduction</h3>
                            <p>The aim of this lab is to familiarize ourselves with the technique of mapping by utilizing the ToF sensor readings, and doing so by mapping the static room that was set up in the class lab space. The map set up by the instructors will further be used in localization and navigation labs later on.</p>
                            <p>The primary goal of the lab was to successfully collect ToF readings and map the obstacles and walls of the room that was set up in the lab, based on four different marked locations within the composed static room. There were various possible approaches to this lab, however, I chose to solve it through utilizing knowledge obtained in Lab 6 on Digital Motion Processing (DMP), which enabled me to obtain consistent ToF readings through keeping track of my measured and expected yaw values, through proposing consistent angular increments.</p>
                          
                            </section>
                            <section class="content-section">
                            <h3>Control and Obtaining ToF Readings</h3>
                            <p>As aforementioned, I opted for approaching the lab through implementing closed-loop control using DMP as per obtained Lab 6 knowledge, which ought to help me obtain low-noise angle measurements for the yaw. Upon defining my global variables, I obtain the initial yaw value through setting a while loop which reads the quarternion from the IMU and successfully converts it inot a yaw value, similarly to how we performed the measurement in Lab 6. The code for this can be found below:</p>
                            <pre><code>icm_20948_DMP_data_t data;
distanceSensor0.startRanging();

// Obtain the initial yaw
while (true) {
    myICM.readDMPdataFromFIFO(&data);
    if ((myICM.status == ICM_20948_Stat_Ok || myICM.status == ICM_20948_Stat_FIFOMoreDataAvail) &&
        (data.header & DMP_header_bitmap_Quat6)) {
    double q1 = ((double)data.Quat6.Data.Q1) / 1073741824.0;
    double q2 = ((double)data.Quat6.Data.Q2) / 1073741824.0;
    double q3 = ((double)data.Quat6.Data.Q3) / 1073741824.0;
    double q0 = sqrt(1.0 - ((q1 * q1) + (q2 * q2) + (q3 * q3)));
    double qw = q0, qx = q2, qy = q1, qz = -q3;
    double t3 = 2.0 * (qw * qz + qx * qy);
    double t4 = 1.0 - 2.0 * (qy * qy + qz * qz);
    initial_yaw = atan2(t3, t4) * 180.0 / PI;
    break;
    }
    for (int step = 0; step < steps; step++) {
        target_yaw = initial_yaw + step * yaw_step;
        if (target_yaw > 180) target_yaw -= 360;
        if (target_yaw < -180) target_yaw += 360;
    //...Perform PID Turn Loop//
}                 </code></pre>
                            <p>Furthermore, I initiate <code>distanceSensor0.startRanging();</code> function on the sensor before starting PID control on the robot in order to start the sensor's timing budget. Afterwards, I perform the calculations of my next target yaw at every angle increment of 10 degrees. The for loop was set to have the total number of steps to be 37, in order to compute the full circle in increments of 10. The further update of target yaw normalizes the values to be within the range of [-180 degrees, 180 degrees] through decrementing 360 degrees if target yaw is greater than 180, and incrementing 360 degrees for the cases of target yaw being smaller than -180 degrees, in order to achieve consistency. Furthermore, this is also performed in order to maintain PID control, as we would not want to perform unnecessary turns of our robot due to a miscalculation in the error (since the target yaw is subtracted from current yaw angle, and hence if target yaw were to be negative and close to -180, it would induce a large positive angle which would initiate the excessive turning, while in reality the turn could be of a much smaller angle if normalized - for instance, <code>error = current_yaw - target_yaw = -178 - (-178) = 356</code>, which should have yielded the turn of <code>4</code> degrees instead). </p>
                            <p>Afterwards, PID Loop Control is established in order to reach the successive target yaw values, as can be seen in the code portion attached below. The PID control is performed based on the equations proposed in Lab 5, and error is computed upon every step increment of 10 degrees. With setting the error less than 2 degrees check, we ensure that we avoid infinite loops, annd accept a small yet precise tolerance to noise, checking the preciseness of the target angle constantly. What is more, the set timeout for the sensor is 3 seconds, after which the robot is programmed to perform a stop, as can be seen in the full lab code section attached below.</p>
                            <pre><code>for (int step = 0; step < steps; step++) {
    target_yaw = initial_yaw + step * yaw_step;
    if (target_yaw > 180) target_yaw -= 360;
    if (target_yaw < -180) target_yaw += 360;

    bool targetReached = false;
    unsigned long turnStartTime = millis();

    // PID Turn Loop
    while (!targetReached && millis() - turnStartTime < 3000) {
        myICM.readDMPdataFromFIFO(&data);
        if ((myICM.status == ICM_20948_Stat_Ok || myICM.status == ICM_20948_Stat_FIFOMoreDataAvail) &&
            (data.header & DMP_header_bitmap_Quat6)) {

        double q1 = ((double)data.Quat6.Data.Q1) / 1073741824.0;
        double q2 = ((double)data.Quat6.Data.Q2) / 1073741824.0;
        double q3 = ((double)data.Quat6.Data.Q3) / 1073741824.0;
        double q0 = sqrt(1.0 - ((q1 * q1) + (q2 * q2) + (q3 * q3)));
        double qw = q0, qx = q2, qy = q1, qz = -q3;
        double t3 = 2.0 * (qw * qz + qx * qy);
        double t4 = 1.0 - 2.0 * (qy * qy + qz * qz);
        current_yaw = atan2(t3, t4) * 180.0 / PI;

        dt = (millis() - last_time) / 1000.0;
        last_time = millis();

        error = current_yaw - target_yaw;
        if (error > 180) error -= 360;
        if (error < -180) error += 360;

        error_sum += error * dt;
        if (error_sum > 150) error_sum = 150;
        if (error_sum < -150) error_sum = -150;

        p_term = Kp * error;
        i_term = Ki * error_sum;
        d_term = Kd * (error - prev_error) / dt;
        pwm = p_term + i_term + d_term;

        prev_error = error;

        if (abs(error) < 2.0) {
            targetReached = true;
            break;
        } 
//...Perform motor rotation code//</code></pre>
                            <p>Lastly, the Tof distance reading is collected upon performing a one second delay which enables accurate sensor reading. Furthermore, the sensor is reset for the next ToF reading through performing <code>distanceSensor0.clearInterrupt();</code>, as well as <code>distanceSensor0.stopRanging();</code> and then starting the sensor again through <code>distanceSensor0.startRanging();</code>. The accumulated values for the particular step increment in the total of 37 steps are appended to their respective arrays, and sent over through Bluetooth to Python for plotting and easier analysis. The arrays I sent over for plotting were the expected yaw measurements, recorded yaw measurements, times they were recorded, as well as the ToF distances at that particular angle and timestamp readings.</p>

                            <pre><code>    //Get distance
    int distance_tof = 0;
    if (distanceSensor0.checkForDataReady()) {
        distance_tof = distanceSensor0.getDistance();
        distanceSensor0.clearInterrupt();
        distanceSensor0.stopRanging();
        distanceSensor0.startRanging();
        Serial.println(distance_tof);
    }

    // Save data to arrays
    expected_yaw_data[step] = step * 10;
    actual_yaw_data[step] = current_yaw;
    timestamps[step] = millis();
    tof_data[step] = distance_tof;
}

//Send collected data arrays
for (int j = 0; j < steps; j++) {
    tx_estring_value.clear();
    tx_estring_value.append(expected_yaw_data[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(actual_yaw_data[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(timestamps[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(tof_data[j]);
    tx_characteristic_string.writeValue(tx_estring_value.c_str());
}</code></pre>

<p>For reference, a full code used for the lab is inclulded below. It ought to be clarified that I used a calibration constant of 1.1 which I multiplied with the pin outputs representing the left set of wheels, as was determined in lab 4.</p>






                            <!-- Image Centered -->
                            <section class="content-section">

                            <details>
                                <summary>Full lab code shown here for reference</summary>
                              
<pre><code>case PID_TURN_FULL:
{
    const int steps = 37;
    const float yaw_step = 10.0;
    double initial_yaw = 0;
    double target_yaw, current_yaw;
    float error = 0, prev_error = 0, error_sum = 0;
    float dt = 0;
    float pwm = 0, p_term, i_term, d_term;
    unsigned long last_time = millis();

    // Arrays for logging set as global variables
    // double actual_yaw_data[steps];
    // double expected_yaw_data[steps];
    // unsigned long time_data[steps];
    // int distance_data[steps];

    icm_20948_DMP_data_t data;
    distanceSensor0.startRanging();

    // Obtain the initial yaw
    while (true) {
    myICM.readDMPdataFromFIFO(&data);
    if ((myICM.status == ICM_20948_Stat_Ok || myICM.status == ICM_20948_Stat_FIFOMoreDataAvail) &&
        (data.header & DMP_header_bitmap_Quat6)) {
        double q1 = ((double)data.Quat6.Data.Q1) / 1073741824.0;
        double q2 = ((double)data.Quat6.Data.Q2) / 1073741824.0;
        double q3 = ((double)data.Quat6.Data.Q3) / 1073741824.0;
        double q0 = sqrt(1.0 - ((q1 * q1) + (q2 * q2) + (q3 * q3)));
        double qw = q0, qx = q2, qy = q1, qz = -q3;
        double t3 = 2.0 * (qw * qz + qx * qy);
        double t4 = 1.0 - 2.0 * (qy * qy + qz * qz);
        initial_yaw = atan2(t3, t4) * 180.0 / PI;
        break;
    }
    }

    for (int step = 0; step < steps; step++) {
    target_yaw = initial_yaw + step * yaw_step;
    if (target_yaw > 180) target_yaw -= 360;
    if (target_yaw < -180) target_yaw += 360;

    bool targetReached = false;
    unsigned long turnStartTime = millis();

    // PID Turn Loop
    while (!targetReached && millis() - turnStartTime < 3000) {
        myICM.readDMPdataFromFIFO(&data);
        if ((myICM.status == ICM_20948_Stat_Ok || myICM.status == ICM_20948_Stat_FIFOMoreDataAvail) &&
            (data.header & DMP_header_bitmap_Quat6)) {

        double q1 = ((double)data.Quat6.Data.Q1) / 1073741824.0;
        double q2 = ((double)data.Quat6.Data.Q2) / 1073741824.0;
        double q3 = ((double)data.Quat6.Data.Q3) / 1073741824.0;
        double q0 = sqrt(1.0 - ((q1 * q1) + (q2 * q2) + (q3 * q3)));
        double qw = q0, qx = q2, qy = q1, qz = -q3;
        double t3 = 2.0 * (qw * qz + qx * qy);
        double t4 = 1.0 - 2.0 * (qy * qy + qz * qz);
        current_yaw = atan2(t3, t4) * 180.0 / PI;

        dt = (millis() - last_time) / 1000.0;
        last_time = millis();

        error = current_yaw - target_yaw;
        if (error > 180) error -= 360;
        if (error < -180) error += 360;

        error_sum += error * dt;
        if (error_sum > 150) error_sum = 150;
        if (error_sum < -150) error_sum = -150;

        p_term = Kp * error;
        i_term = Ki * error_sum;
        d_term = Kd * (error - prev_error) / dt;
        pwm = p_term + i_term + d_term;

        prev_error = error;

        if (abs(error) < 2.0) {
            targetReached = true;
            break;
        }

        if (pwm > maxSpeed) pwm = maxSpeed;
        if (pwm < -maxSpeed) pwm = -maxSpeed;

        if (pwm < -80) {
            analogWrite(PIN0, abs(pwm)); analogWrite(PIN1, 0);
            analogWrite(PIN3*1.1, abs(pwm)); analogWrite(PIN2, 0);
        }
        else if (pwm > 80) {
            analogWrite(PIN0, 0); analogWrite(PIN1, abs(pwm));
            analogWrite(PIN3, 0); analogWrite(PIN2*1.1, abs(pwm));
        }
        else {
            analogWrite(PIN0, 0); analogWrite(PIN1, 0);
            analogWrite(PIN3, 0); analogWrite(PIN2, 0);
        }

        delay(10);
        }
    }

    // Stop the motors
    analogWrite(PIN0, 0); analogWrite(PIN1, 0);
    analogWrite(PIN3, 0); analogWrite(PIN2, 0);

    delay(1000); // Pause for 1 second at this angle

    // Get distance
    int distance_tof = 0;
    if (distanceSensor0.checkForDataReady()) {
        distance_tof = distanceSensor0.getDistance();
        distanceSensor0.clearInterrupt();
        distanceSensor0.stopRanging();
        distanceSensor0.startRanging();
        Serial.println(distance_tof);
    }

    // Save data to arrays
    expected_yaw_data[step] = step * 10;
    actual_yaw_data[step] = current_yaw;
    timestamps[step] = millis();
    tof_data[step] = distance_tof;
    }

    //Send collected data arrays
    for (int j = 0; j < steps; j++) {
    tx_estring_value.clear();
    tx_estring_value.append(expected_yaw_data[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(actual_yaw_data[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(timestamps[j]);
    tx_estring_value.append("|");
    tx_estring_value.append(tof_data[j]);
    tx_characteristic_string.writeValue(tx_estring_value.c_str());
    }

    Serial.println("A full 360 turn complete. Sending the data!");
    break;
} </code></pre>                 </details>

                                <p>Apart from the proposed Arduino code, on the Python side of things, I implemented a notification handler for collecting the data arrays, similarly to how I have performed it in previous labs.</p>
                                <pre><code>expected_yaw = []
actual_yaw = []
timestamp = []
tof_distance = []
def lab9_turns(uuid, bytes):
    s = ble.bytearray_to_string(bytes)
    if("|" in s):
        sep_notif = s.split("|")
        expected_yaw.append(float(sep_notif[0]))
        actual_yaw.append(float(sep_notif[1]))
        timestamp.append(float(sep_notif[2]))
        tof_distance.append(float(sep_notif[3]))
        
ble.start_notify(ble.uuid['RX_STRING'], lab9_turns)</code></pre>

                                <p>Afterwards, the PID control gains, as well as the maximum speed (from 0 to 255) were set by running the command in Python in order to tune the robot well for the tiles surface, as appropriate for the lab setup. The Arduino code for <code>CHANGE_GAIN</code> case will be attached for reference from Lab 5.</p>
                                <pre><code>ble.send_command(CMD.CHANGE_GAIN, "3.5|0.000001|2|150") # Python end</code></pre>
                                <pre><code>  case CHANGE_GAIN: # Arduino end
    {
        float new_kp; float new_ki; float new_kd; float new_maxSpeed;
        
        success = robot_cmd.get_next_value(new_kp);
        if(!success)
        return;

        success = robot_cmd.get_next_value(new_ki);
        if(!success)
        return;

        success = robot_cmd.get_next_value(new_kd);
        if(!success)
        return;

        success = robot_cmd.get_next_value(new_maxSpeed);
        if(!success)
        return;

        Kp = new_kp;
        Ki = new_ki;
        Kd = new_kd;
        maxSpeed = new_maxSpeed;
        break;
    }</code></pre>

                                <p>After this, the command for running <codd>PID_TURN_FULL</code> case was initiated, which starts the rotation of the robot. The command can be found below. With this, we are ready to receive and analyze the collected data!</p>
                                <pre><code>ble.send_command(CMD.PID_TURN_FULL, "")</code></pre>
                                
                                <p>Another significant thing to note is that even though one of DMP's main benefits is the fact that it greatly minimizes drift, as will be seen in later parts of this lab report with the static room wall mapping, there was a slight translation in the axis that did corresponded to minor error and noise, especially in initial stages of testing. Through conversation with Aidan McNay in open hours, I learned to change my sensors' timing bdget to 200 ms for sampling, as well as intermeasurement period to 250 ms in-between samples. Particularly, I was not allowing my sensors to have enough time to appropriately measure distances, which resulted in a lot of incorrect measurements being accumulated, producing indigestible and inaccurate plots. The plots might not have been useful for further analysis and mapping, but surely produced some pretty shapes, as can be seen in bloopers section below!</p>



                                <h3>Discussion</h3>
                                <p>This lab was one of the most interesting labs in my opinion, it presents us with a new chapter into localization and planning, as well as incorporates the knowledge obtained in many previous labs, fundamentally Lab 6.</p>
    
                        

                    
                            </section>
                            <h4>Acknowledgements and References</h4>
                            <p>*I worked with Becky Lee on this lab, and Ben Liao who helped me with understanding conversion to global frame. I referenced Ben Liao's website (2025) since I got help from him, as well as Wenyi Fu's website (2024) in order to understand the material better. Apart from the Becky and Ben, thank you to TA Cameron for helping me fix my ToF sensor connections, as well as TA Cheney for generously prolonging his office hours for testing purposes.</p>

                        
                        <!-- </article> -->
                    
                    </body>
 
                    

                    

                    
                    

                    <!-- Posts -->


                    <!-- Footer -->
                </div>
                </div>
            <!-- Footer -->
            <footer id="footer">
                    <!-- <section>
                        <form method="post" action="#">
                            <div class="fields">
                                <div class="field">
                                    <label for="name">Name</label>
                                    <input type="text" name="name" id="name" />
                                </div>
                                <div class="field">
                                    <label for="email">Email</label>
                                    <input type="text" name="email" id="email" />
                                </div>
                                <div class="field">
                                    <label for="message">Message</label>
                                    <textarea name="message" id="message" rows="3"></textarea>
                                </div>
                            </div>
                            <ul class="actions">
                                <li><input type="submit" value="Send Message" /></li>
                            </ul>
                        </form>
                    </section>
                    <section class="split contact"> -->
                        <section>
                            <h3>EMAIL @ </h3>
                            <p><a href="#">kd374@cornell.edu</a></p>
                        </section>
                </footer> 

            <!-- Copyright -->
                <div id="copyright">
                    <ul><li>&copy; Untitled</li><li>Design: <a href="https://html5up.net">HTML5 UP</a></li></ul>
                </div>

        </div>

    <!-- Scripts -->
        <script src="assets/js/jquery.min.js"></script>
        <script src="assets/js/jquery.scrollex.min.js"></script>
        <script src="assets/js/jquery.scrolly.min.js"></script>
        <script src="assets/js/browser.min.js"></script>
        <script src="assets/js/breakpoints.min.js"></script>
        <script src="assets/js/util.js"></script>
        <script src="assets/js/main.js"></script>

</body>
</html>
                    

                      
